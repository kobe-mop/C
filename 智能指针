这些智能指针在设计的时候，一个关键的问题就是所有权的控制。如果把指针所指向的对象比作电视机的话，那么指针就是观众。第一个人需要看电视的时候需要打开它，
没人看的时候就要保证把电视关掉。

对于std::auto_ptr,boost::shared_ptr和scoped_ptr，情况如下：

1. std::auto_ptr：auto_ptr这个种族很有趣，每次只让一个人看电视，大家可以换着看，由最后那个不想看的人关掉。当把一个auto_ptr赋值给另一个时，
就好比换一个人看电视似的。总之，电视只能一个人看，第二个人想看第一个就得让位。
2. boost::shared_ptr：这个种族就很大方了，有好节目大家一起看:)只要最后一个看电视的人走的时候关掉就好了。看电视的每个人都知道当时有多少人在看，
所以最后一个人知道自己的确是最后一个人。
3. boost::scoped_ptr：这是最自私的种族，每个电视只能让一个人看，别人门都没有。所以你不要试图去复制一个scoped_ptr对象。自己的电视自己处理，
为了省电自己也得关吧，的确很安全，

所以，auto_ptr的机理就是复制时转移所有权，也就是所指的对象永远最多为一个auto_ptr对象所有，这样就能保证对象能安全的释放。
shared_ptr基于引用计数，当把一个shared_ptr赋给另一个时，引用计数加一，当一个shared_ptr析构时，引用计数减一，当减为零时释放对象。
而scoped_ptr不允许复制，所以自始至终对象由唯一的scoped_ptr创建，维护并释放。
--------------------- 
